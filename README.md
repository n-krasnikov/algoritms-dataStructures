# Data structures and Algorithms

### Общая часть

- [ ] Знать что такое оценочная сложность алгоритмов и структур данных, понимать при чем тут O.
- [ ] Уметь определять временную сложность алгоритма, взаимодействия со структурой данных.
- [ ] Уметь определять пространственную сложность алгоритма, структуры данных.
- [ ] Знать что такое абстрактный тип данных.

---
### Структуры данных

- [ ] Знать что такое массив, как с ним взаимодействовать.
- [ ] Знать что такое связный список, как с ним взаимодействовать.
- [ ] Знать что такое FIFO и LIFO и зачем они нужны. Знать структуры данных, в которых они используются и как с этими структурами взаимодействовать.
- [ ] Знать что такое словарь, как с ним взаимодействовать.
- [ ] Знать что такое хеш-таблица, как с ней взаимодействовать. Понимать почему возникают коллизии, почему и как их можно избегать.

- [ ] Уметь сравнивать структуры данных.
- [ ] Уметь выбирать оптимальные структуры данных для решения задач.

---
### Сортировка

- [ ] Знать популярные алгоритмы сортировки (минимум 2 со средней временной сложностью n*log(n) или выше).
- [ ] Уметь написать любой (на выбор принимающего) алгоритм сортировки из перечисленных.

---
### Поиск

- [ ] Знать какие есть алгоритмы поиска, и их назначение.

---

### Общая часть
> Что такое оценочная сложность алгоритмов и структур данных, понимать при чем тут O.

"Сложность" в данном контексте делится на __2__ вида:
1. Временная
2. Пространственная

#### Пространственная
Алгоритм - по своей сути обычная функция которая во время выполнения может пораждать рекурсию и заводить новые переменные.  
На всё это необходима память - Сколько алгоритму необходимо памяти такая у него пространственная сложность.


#### Временная
Для выполнения любой операции необходимо время. Сравнение, сложение, умножение на всё это потребуется время.  
Так как алгоритм это функция со своим набором операций - время на их выполнение и будет считаться его временной сложностью.  
Но время выполнения зависит от конкретного устройства на котором исполняется алгоритм. Ведь на старом железе алгоритм будет работать медленнее чем на новом. Для того чтобы определять сложность алгоритма независимо от конкретного устройства ввели **O**.

Стоит обговорить, что принято считать **O** именно в худшем случае *(для лучшего случая использется **Ω**)*

упрощённо - **O** это время на выполнение одной операции 

> Как определять временную сложность?

Основываясь на том что **O** расчитывается для худшего случая рассмотрим примеры с массивом из N  элементов:
1. Посчитать сумму элементов массива
2. Получить элемент с определённым индексом

Для первого случая сложность будет **O(n)** Так как нам придётся по всем n элементам массива
Для второго случая **O(1)** Так как массив позволяет обращаться к элементам по индексу и займёт это лишь одну операцию

Стоит отметить что для случаев когда в нашем алгоритме берутся всего 3 элементв *(допустим в начале, середине и конце)*.  Сложность алгоритма не будет равняться O(3). В данном случае 3 - константа, в нашем алгоритме всегда будет браться только 3 элемента и это никак не зависит от входных данных. Здесь можно привести аналогию с производными, константы сокращаются до 1.

> Как определять пространственную сложность?

Здесь всё куда проще, как правило достаточно лишь посчитать количество самовызовов алгоритма. Если алгоритм не пораждает рекурсии или вызывается константное количество раз *(например идет от начала до конца массива и обратно)* - его сложность **O(1)** Далее зависит от количества самовызовов

> Что такое абстрактный тип данных?

Абстрактный тип данных это описание/интерфейс.  
То какие методы, переменные необходимы для использования этого типа данных.  
Уже реализация методов абстрактного типа называется структурой данных.  
Использование абстрактных типов данных позволяет дорабатывать и улучшать те самые методы без вмешательства в те места где они использовались.

---
### Структуры данных

> Что такое массив?

Массив это структура данных которая имеет длинну и все её элементы проиндексированны.  
В массиве все элементы записаны в памяти последовательно.

При получении элемента мы просто обращаемя к нему по индексу.  
При добавлении элемента в конец массива никаких преобразований не произойдёт.  
При добавлении элемента в начало необходимо будет пересчитать все индексы.  
При поиске необходимо пройтись по каждому элементу.  
При удалении ситуация та же что и с добавлением.  

| Действие          | Сложность    |
|-------------------|--------------|
| Получение         | O(1)         |
| Вставка в начало  | O(1)         |
| Вставка в конец   | O(n)         |
| Поиск             | O(n)         |
| Удаление в конце  | O(1)         |
| Удаление в начале | O(n)         |

>  Что такое связный список?

Связный список структура данных которая имеет:     
- Хвост
- Голову

Голова и хвост пердставляют из себя уже другую структуру данных - узел списка  
Он в свою очередь состоит из:
- Значения
- Ссылки на следующий узел

Итак, списки бывают трёх видов:
1. Связный список
2. Двусвязный список
3. Замкнутый список

Пример обычного связного списка пердставлен выше.  
В случае двусвязного списка у каждого узла добавляется ссылка на предыдущий узел.
В замкнутом списке хвост ссылается на голову. В случае когда это двусязный замкнутый голова и хвост ссылаются друг на друга. 

При получении конкретного узла мы вынуждены пройти по всему списку начиная от головы.  
При добавлении узла в начало или конец мы просто меняем голову/хвост.  
При добавлении в середину нам необходимо пройтись от головы до нужного нам узла и сменить ссылку на последующий узел.  
При поиске мы так же как в ситуации со вставкой должны проходиться по узлам. 
Удаление так же идентично добавлению узлов

| Действие         | Сложность    |
|------------------|--------------|
| Получение        | O(N)         |
| Вставка в начало | O(1)         |
| Вставка в центр  | O(n)         |
| Поиск            | O(n)         |
| Удвление         | O(n)         |


> Что такое LIFO и FIFO?

**FIFO** - First In First Out / *Первый пришёл перый ушёл*  
Структура данных типа "Очередь"  
Аналогия с обычной очередью в магазине. Чем раньше ты пришёл на кассу - тем раньше уйдёшь

Очередь основана на связном списке, но при этом имеет свои ограничения.  
Мы можем добавлять новые узлы только к хвосту, а извлекать элементы мы можем только из головы

**LIFO** - Last In First Out / *Последний пришёл первый ушёл*
Структура данных типа "Стек"
Аналогия со стопкой книг. Нельзя взять книгу пока на ней лежат другие книги.  

Стек тоже как и очередь основан на связных списках и так же как и очередь имеет свои ограничения.  
Мы можем добавлять элементы только к хвосту, и извлекать их можем так же только из него.


Оба этих подхода можно встретить в Event Loop:
- **FIFO** - Коллстек (CallStack)
- **LIFO** - Очередь коллбеков (CallBack Queue)

От того в их названиях и есть "Stack" и "Queue"

> Что такое словарь?

Словарь это структура данных в которой данные храянтся парой ключ - значение  
Ключ представлен в виде строки
//пока сказать больше нечего

> Что такое хеш-таблица?

Хэш таблица это по своей сути тоже словарь, но не зря её вынесли в отдельный тип данных  
Данные хранятся тоже в виде хэш - (ключ, значение)  
Но в случае хэш таблиц ключём может быть что угодно так как данные хранятся по хэшу от ключа  
Хоть хэш и создаёт всегда разные строки, но они фиксированной длины, а значит количество вариантов конечно  
Из этого следует что возможна ситуация когда от двух разных ключей сформируется одинаковый хэш  
Такие случаи называются коллизиями и есть несколько вариантов их решения:
1. Метод списков  
   В этом случае значения по хэшу представляют собой список. И в случае добавления нового элемента будет просто добавлен новый узел к хвосту
2. Метод открытой адресации  
   В этом случае мв просто запишем значение в следующую свободную ячейку.
3. Метод двойного хэширования  
   В этом случае от хэш уже будет браться от полученного хэша и будет продолжаться до тех пор пока не найдётся свободная ячейка

Приемущество хэш таблиц в том что ключами могут являться любые объекты, а так же это удобно если ключи представляют собой очень длинные строки.

---

##### Пара вопросов:

<details>
  <summary>Для чего ты использовал массив?</summary>
  Морской бой / шахматная доска  
  Это хоть и двумерный массив, но это те места в которых необходима индексация для навигации, что неплохо отражает суть массивов
</details>

<details>
  <summary>Для чего ты бы использовал список?</summary>
  Форма теста или образовательный курс
  Суть в том что нельзя перепрыгнуть сразу на какой-то этам, необходимо пройтись по каждому
</details>

<details>
  <summary>Для чего ты бы использовал очередь и стек?</summary>
  Выше был пример про Event Loop 
</details>

<details>
  <summary>Для чего ты бы использовал словарь?</summary>
  Обычная задачка, юзер со строковыми полями.  
  Строки не очень длинные, по ним легко ориентироваться
</details>

<details>
  <summary>Для чего ты бы использовал хэш таблицу?</summary>
  Git  
  У коммита есть хэш, а в коммите хранятся все данные
</details>

---

### Сортировки

Рассмотрим три алгоритма сортировки:  
1. Bubble Sort  
    Суть заключается в том что мы проходимся одним циклом по каждому элементу массива.  
    Внутри этого цикла мы вновь проходимся по всемм элементам массива и сравниваем.  
    Если больше - меняем местами, нет оставляем на месте
2. Quick Sort  
    В классической реализации мы выбираем опорный элемент в центре массива.  
    Далее заводим 2 указателя. Один в начале массива, другой в концк и двигаем их навстречу друг другу.  
    Как только указатель слева находит элемент больше опорного, а правый находит элемент меньше опорного - они обмениваются элементами.  
    И так повторяется для каждого подмассива разделённого опорным элементом пока длинна этого массива <= 1 
3. Merge Sort  
   Суть состоит в том что исходный элемент делится на части до тех пор пока полученные подмассивы не станут длинной 1 или 2 символа.  
   В случае если он сосоит из 2х элементов, мы сравниваем его и сортируем по необходимости.  
   Далее вступает в силу вспомогательная функция слияния которая принимет в себя 2 массива и возвращает объединённый отсортированный массив.  



